// MACC_N_CHEESE Grammar 2016
// 
// Parser Class Implementation File

// SHELL GENERATED BY PARSERGEN VERSION 5.0.3

#include <iostream>
#include <string>
#include <fstream>
#include <iomanip>
using namespace std;

#include "mncParser.h"
extern Scanner scan;
extern CodeGen code;

extern ifstream sourceFile;
extern ofstream outFile, listFile;

Parser::Parser()
{
	tokenAvailable = false;
}

void Parser::SyntaxError(Token t, string msg)
{
	cout << "Syntax Error: " + msg << endl;
	exit(1); // abort on any syntax error
}

Token Parser::NextToken()
{
	if (!tokenAvailable)
	{
		savedToken = scan.GetNextToken();
		tokenAvailable = true;
	}
	return savedToken;
}

void Parser::Match(Token t)
{
	if (t != NextToken())
		SyntaxError(t, "");
	else
		tokenAvailable = false;
}


void Parser::InitTail()
{
    Expr initTailExpr;
	switch (NextToken())
	{
	case COMMA:
		Match(COMMA);
		Expression(initTailExpr);
		InitTail();
		break;
	case RMUSTACHE:
		break;
	default:
		SyntaxError(NextToken(), "");
	}
}

void Parser::VarDecTail(ExprType& type, bool HipOrNah, int HipHip_Size, int cheeseSize)
{
	switch (NextToken())
	{
	case COMMA:
		Match(COMMA);
		Match(ID);
		code.DefineVar(type, HipOrNah, HipHip_Size, cheeseSize);
		VarDecTail(type, HipOrNah, HipHip_Size, cheeseSize);
		break;
	case SEMICOLON:
		break;
	default:
		SyntaxError(NextToken(), "");
	}
}

void Parser::VarDecList(ExprType& type, bool HipOrNah, int HipHip_Size, int cheeseSize)
{
	Match(ID);
	code.DefineVar(type, HipOrNah, HipHip_Size, cheeseSize);
	VarDecTail(type, HipOrNah, HipHip_Size, cheeseSize);
}

void Parser::DecTail()
{
	switch (NextToken())
	{
	case BOOL_SYM:
	case CHEESE_SYM:
	case FLOAT_SYM:
	case HIPHIP_SYM:
	case INT_SYM:
		Declaration();
		DecTail();
		break;
	case RMUSTACHE:
		break;
	default:
		SyntaxError(NextToken(), "");
	}
}

void Parser::Declaration()
{
	bool HipOrNah = false;
    int Cheese_Size = 0;
	ExprType type;
	switch (NextToken())
	{
	case BOOL_SYM:
	case CHEESE_SYM:
	case FLOAT_SYM:
	case INT_SYM:
		Type(type, Cheese_Size);
		Match(COLON);
		VarDecList(type, HipOrNah, 0,  Cheese_Size);
		Match(SEMICOLON);
		break;
	case HIPHIP_SYM:
		int HipHip_Size;
		Match(HIPHIP_SYM);
		Match(LSTAPLE);
		Match(INT_LIT);
        HipHip_Size = atoi(scan.tokenBuffer.data());
		Match(RSTAPLE);
		Type(type, Cheese_Size);
		Match(COLON);
		HipOrNah = true;
		VarDecList(type, HipOrNah, HipHip_Size, Cheese_Size);
		Match(SEMICOLON);
		break;
	default:
		SyntaxError(NextToken(), "");
	}
}

void Parser::DecList()
{
	Declaration();
	DecTail();
}

void Parser::BoolLit(Expr& expr)
{
    expr.theType = boolType;
	switch (NextToken())
	{
	case FALSE_SYM:
        expr.boolVal = false;
		Match(FALSE_SYM);
		break;
	case TRUE_SYM:
        expr.boolVal = true;
		Match(TRUE_SYM);
		break;
	default:
		SyntaxError(NextToken(), "");
	}
}

void Parser::CheeseTypeTail(int& Cheese_size)
{

	switch (NextToken())
	{
	case LSTAPLE:
		Match(LSTAPLE);
		Match(INT_LIT);
		Cheese_size = atoi(scan.tokenBuffer.data());
		Match(RSTAPLE);
		break;
	case COLON:
	case ID:
        Cheese_size = 1024;
		break;
	default:
		SyntaxError(NextToken(), "");
	}
}

void Parser::CheeseType(int& Cheese_size)
{
	Match(CHEESE_SYM);
	CheeseTypeTail(Cheese_size);
}

void Parser::Type(ExprType& type, int& Cheese_Size)
{
	switch (NextToken())
	{
	case BOOL_SYM:
        type = boolType;
		Match(BOOL_SYM);
		break;
	case INT_SYM:
        type = intType;
		Match(INT_SYM);
		break;
	case FLOAT_SYM:
        type = floatType;
		Match(FLOAT_SYM);
		break;
	case CHEESE_SYM:
        type = cheeseType;
		CheeseType(Cheese_Size);
		break;
	default:
		SyntaxError(NextToken(), "");
	}
}

void Parser::Literal(Expr& expr)
{
	switch (NextToken())
	{
	case FALSE_SYM:
	case TRUE_SYM:
		BoolLit(expr);
		break;
	case INT_LIT:
        expr.theType = intType;
		Match(INT_LIT);
		break;
	case FLOAT_LIT:
        expr.theType = floatType;
		Match(FLOAT_LIT);
		break;
	case CHEESE_LIT:
        expr.theType = cheeseType;
		Match(CHEESE_LIT);
		break;
	default:
		SyntaxError(NextToken(), "");
	}
}

void Parser::MultOp()
{
	switch (NextToken())
	{
	case MULT_OP:
		Match(MULT_OP);
		break;
	case DIV_OP:
		Match(DIV_OP);
		break;
	default:
		SyntaxError(NextToken(), "");
	}
}

void Parser::FactorTail(Expr& expr)
{
	OpRec op;
	op.leftSide = expr;
    Expr factorTailExpr;
	switch (NextToken())
	{
	case MULT_OP:
	case DIV_OP:
		MultOp();
		code.ProcessOp(op);
		Primary(factorTailExpr);
		op.rightSide = 	factorTailExpr;
		code.GenInfix(op, expr);
		FactorTail(factorTailExpr);
		break;
	case RSTAPLE:
	case RBANANA:
	case RMUSTACHE:
	case SEMICOLON:
	case COMMA:
	case PLUS_OP:
	case MINUS_OP:
	case LT_OP:
	case LE_OP:
	case GT_OP:
	case GE_OP:
	case EQ_OP1:
	case EQ_OP2:
	case NE_OP:
		break;
	default:
		SyntaxError(NextToken(), "");
	}
}

void Parser::Primary(Expr& expr)
{
    //Expr primaryExpr;
	switch (NextToken())
	{
	case FALSE_SYM:
	case TRUE_SYM:
	case INT_LIT:
	case FLOAT_LIT:
	case CHEESE_LIT:
		Literal(expr);
		code.ProcessLit(expr);
		break;
	case ID:
		Variable(expr);
		code.ProcessVar(expr);
		break;
	case LBANANA:
		Match(LBANANA);
		Expression(expr);
		Match(RBANANA);
		break;
	default:
		SyntaxError(NextToken(), "");
	}
}

void Parser::AddOp()
{
	switch (NextToken())
	{
	case PLUS_OP:
		Match(PLUS_OP);
		break;
	case MINUS_OP:
		Match(MINUS_OP);
		break;
	default:
		SyntaxError(NextToken(), "");
	}
}

void Parser::ExprTail(Expr& expr)
{
    Expr exprTailExpr;
	OpRec op;
	op.leftSide = expr;
	switch (NextToken())
	{
	case PLUS_OP:
	case MINUS_OP:
		AddOp();
		code.ProcessOp(op);
		Factor(exprTailExpr);
		op.rightSide = exprTailExpr;
		code.GenInfix(op, expr);
		ExprTail(expr);
		break;
	case RSTAPLE:
	case RBANANA:
	case RMUSTACHE:
	case SEMICOLON:
	case COMMA:
	case LT_OP:
	case LE_OP:
	case GT_OP:
	case GE_OP:
	case EQ_OP1:
	case EQ_OP2:
	case NE_OP:
		break;
	default:
		SyntaxError(NextToken(), "");
	}
}

void Parser::Factor(Expr& expr)
{
	Primary(expr);
	FactorTail(expr);
}

void Parser::RelOp()
{
	switch (NextToken())
	{
	case LT_OP:
		Match(LT_OP);
		break;
	case LE_OP:
		Match(LE_OP);
		break;
	case GT_OP:
		Match(GT_OP);
		break;
	case GE_OP:
		Match(GE_OP);
		break;
	case EQ_OP1:
		Match(EQ_OP1);
		break;
	case EQ_OP2:
		Match(EQ_OP2);
		break;
	case NE_OP:
		Match(NE_OP);
		break;
	default:
		SyntaxError(NextToken(), "");
	}
}

void Parser::CondTail(OpRec& opRec)
{
    Expr condTailExpr;
	switch (NextToken())
	{
	case LT_OP:
	case LE_OP:
	case GT_OP:
	case GE_OP:
	case EQ_OP1:
	case EQ_OP2:
	case NE_OP:
		RelOp();
		code.ProcessOp(opRec);
		Expression(condTailExpr);
		opRec.rightSide = condTailExpr;

		break;
	case RBANANA:
	case SEMICOLON:
		break;
	default:
		SyntaxError(NextToken(), "");
	}
}

void Parser::IntListTail()
{
	switch (NextToken())
	{
	case COMMA:
		Match(COMMA);
		Match(INT_LIT);
		// code.IntAppend();
		IntListTail();
		break;
	case COLON:
		break;
	default:
		SyntaxError(NextToken(), "");
	}
}

void Parser::IntList()
{
	Match(INT_LIT);
	// code.IntAppend();
	IntListTail();
}

void Parser::CaseListTail()
{
	switch (NextToken())
	{
	case CASE_SYM:
		Case();
		CaseListTail();
		break;
	case OTHERWISE_SYM:
		break;
	default:
		SyntaxError(NextToken(), "");
	}
}

void Parser::Case()
{
	Match(CASE_SYM);
	IntList();
	Match(COLON);
	StmtList();
	// code.CaseEnd();
}

void Parser::CaseList()
{
	Case();
	CaseListTail();
}

void Parser::ForAssign()
{
    Expr forAssignExpr;
	Variable(forAssignExpr);
	// code.ProcessVar();
	Match(ASSIGN_OP);
	Expression(forAssignExpr);
	// code.ForAssign();
}

void Parser::ElseClause(bool& isElse)
{
	switch (NextToken())
	{
	case ELSE_SYM:
		Match(ELSE_SYM);
		isElse = true;
			//set variable to truuuuue and pass it into ifend
		code.IfElse();
		StmtList();
		break;
	case END_SYM:
		break;
	default:
		SyntaxError(NextToken(), "");
	}
}

void Parser::Condition(OpRec& opRec)
{
    Expr condExpr;
	Expression(condExpr);
	opRec.leftSide = condExpr;
	CondTail(opRec);
	code.SetCondition(opRec);
}

void Parser::VarDecs()
{
	Match(DECS_SYM);
	Match(LMUSTACHE);
	DecList();
	Match(RMUSTACHE);
}

void Parser::SelectStmt()
{
    Expr selectExpr;
	Match(SELECT_SYM);
	Match(LBANANA);
	Expression(selectExpr);
	Match(RBANANA);
	// code.SelectBegin();
	CaseList();
	Match(OTHERWISE_SYM);
	// code.Otherwise();
	Match(COLON);
	StmtList();
	// code.CaseEnd();
	Match(END_SYM);
	// code.SelectEnd();
}

void Parser::ForStmt()
{
	OpRec ForOp;
	Match(FOR_SYM);
	Match(LBANANA);
	ForAssign();
	Match(SEMICOLON);
	Condition(ForOp);
	// code.ForBegin();
	Match(SEMICOLON);
	ForAssign();
	// code.ForUpdate();
	Match(RBANANA);
	StmtList();
	Match(END_SYM);
	// code.ForEnd();
}

void Parser::WhileStmt()
{
	OpRec WhileOp;
	Match(WHILE_SYM);
	Match(LBANANA);
	Condition(WhileOp);
	Match(RBANANA);
	// code.WhileBegin();
	StmtList();
	Match(END_SYM);
	// code.WhileEnd();
}

void Parser::LoopStmt()
{
	OpRec loopOp;
	Match(DO_SYM);
	// code.LoopBegin();
	StmtList();
	Match(UNTIL_SYM);
	Match(LBANANA);
	Condition(loopOp);
	Match(RBANANA);
	// code.LoopEnd();
	Match(SEMICOLON);
}

void Parser::IfStmt()
{
	bool isThereAnElse;
	OpRec ifOpRec;
	Match(IF_SYM);
	Match(LBANANA);
	Condition(ifOpRec);
	Match(RBANANA);
	code.IfThen(ifOpRec);
	StmtList();
	ElseClause(isThereAnElse);
	Match(END_SYM);
	code.IfEnd(isThereAnElse);
}

void Parser::ItemListTail()
{
    Expr shoutExpr;
    switch (NextToken())
	{
        case COMMA:
		Match(COMMA);
		Expression(shoutExpr);
        code.Shout(shoutExpr);
		ItemListTail();
		break;
	case SEMICOLON:
		break;
	default:
		SyntaxError(NextToken(), "");
	}
}

void Parser::ItemList()
{
	Expr shoutExpr;
	Expression(shoutExpr);
	code.Shout(shoutExpr);
	ItemListTail();
}

void Parser::VariableTail(Expr& expr)
{
    Expr varTail;
	switch (NextToken())
	{
	case LSTAPLE:
		Match(LSTAPLE);
		Expression(varTail);
		code.HipHipIndex(expr, varTail);
		Match(RSTAPLE);
		break;
	case RSTAPLE:
	case RBANANA:
	case RMUSTACHE:
	case SEMICOLON:
	case COMMA:
	case ASSIGN_OP:
	case PLUS_OP:
	case MINUS_OP:
	case MULT_OP:
	case DIV_OP:
	case LT_OP:
	case LE_OP:
	case GT_OP:
	case GE_OP:
	case EQ_OP1:
	case EQ_OP2:
	case NE_OP:
		break;
	default:
		SyntaxError(NextToken(), "");
	}
}

void Parser::VarListTail()
{
	Expr varListTailExpr;
	switch (NextToken())
	{
	case COMMA:
		Match(COMMA);
		Variable(varListTailExpr);
		code.ProcessVar(varListTailExpr);
		code.Listen(varListTailExpr);
		VarListTail();
		break;
	case SEMICOLON:
		break;
	default:
		SyntaxError(NextToken(), "");
	}
}

void Parser::VarList()
{
	Expr varListExpr;
	Variable(varListExpr);
	code.ProcessVar(varListExpr);
	code.Listen(varListExpr);
	VarListTail();
}

void Parser::InitList()
{
    Expr initListExpr;
	Expression(initListExpr);
	InitTail();
}

void Parser::Expression(Expr& expr)
{  //TODO set up opRec and make result be an expr that's passed back up
	Factor(expr);
	ExprTail(expr);
}

void Parser::AssignTail(Expr & assignTailExpr)
{
	switch (NextToken())
	{
	case FALSE_SYM:
	case TRUE_SYM:
	case LBANANA:
	case ID:
	case INT_LIT:
	case FLOAT_LIT:
	case CHEESE_LIT:
		Expression(assignTailExpr);
		break;
	case LMUSTACHE:
		Match(LMUSTACHE);
		InitList();
		Match(RMUSTACHE);
		break;
	default:
		SyntaxError(NextToken(), "");
	}
}

void Parser::Variable(Expr& expr)
{
	Match(ID);
	expr.ID = scan.tokenBuffer;
	VariableTail(expr);
}

void Parser::BreakStmt()
{
	Match(BREAK_SYM);
	// code.Break();
	Match(SEMICOLON);
}

void Parser::ShoutStmt()
{
	Match(SHOUT_SYM);
	ItemList();
	code.NewLine();
	Match(SEMICOLON);
}

void Parser::ListenStmt()
{
	Match(LISTEN_SYM);
	VarList();
	Match(SEMICOLON);
}

void Parser::AssignStmt()
{
    Expr AssignExpr;
    Expr AssignTailExpr;
	Variable(AssignExpr);
	code.ProcessVar(AssignExpr);
	Match(ASSIGN_OP);
	AssignTail(AssignTailExpr);
	code.Assign(AssignExpr, AssignTailExpr);
	Match(SEMICOLON);
}

void Parser::StructStmt()
{
	switch (NextToken())
	{
	case IF_SYM:
		IfStmt();
		break;
	case DO_SYM:
		LoopStmt();
		break;
	case WHILE_SYM:
		WhileStmt();
		break;
	case FOR_SYM:
		ForStmt();
		break;
	case SELECT_SYM:
		SelectStmt();
		break;
	case DECS_SYM:
		VarDecs();
		break;
	default:
		SyntaxError(NextToken(), "");
	}
}

void Parser::SimpleStmt()
{
	switch (NextToken())
	{
	case ID:
		AssignStmt();
		break;
	case LISTEN_SYM:
		ListenStmt();
		break;
	case SHOUT_SYM:
		ShoutStmt();
		break;
	case BREAK_SYM:
		BreakStmt();
		break;
	default:
		SyntaxError(NextToken(), "");
	}
}

void Parser::StmtTail()
{
	switch (NextToken())
	{
	case BREAK_SYM:
	case DECS_SYM:
	case DO_SYM:
	case FOR_SYM:
	case IF_SYM:
	case LISTEN_SYM:
	case SELECT_SYM:
	case SHOUT_SYM:
	case WHILE_SYM:
	case ID:
		Statement();
		StmtTail();
		break;
	case EOF_SYM:
	case CASE_SYM:
	case ELSE_SYM:
	case END_SYM:
	case OTHERWISE_SYM:
	case UNTIL_SYM:
		break;
	default:
		SyntaxError(NextToken(), "");
	}
}

void Parser::Statement()
{
	switch (NextToken())
	{
	case BREAK_SYM:
	case LISTEN_SYM:
	case SHOUT_SYM:
	case ID:
		SimpleStmt();
		break;
	case DECS_SYM:
	case DO_SYM:
	case FOR_SYM:
	case IF_SYM:
	case SELECT_SYM:
	case WHILE_SYM:
		StructStmt();
		break;
	default:
		SyntaxError(NextToken(), "");
	}
}

void Parser::StmtList()
{
	Statement();
	StmtTail();
}

void Parser::Program()
{
	code.Start();
	StmtList();
	code.Finish();
}

void Parser::SystemGoal()
{
	Program();
	Match(EOF_SYM);
}

void Parser::SyntaxError(Token t)
{
	cout << " *** Syntax Error Detected " << int(t) << ' '
	<< int(savedToken);
	listFile << " *** Syntax Error Detected " << int(t) << ' '
	<< int(savedToken);
	sourceFile.close();
	listFile.close();
	outFile.close();
	cin.ignore(256, '\n');
	cin.get();
	exit(1);  // error termination
}
